[{"uri":"/index.html","title":"F# For You!\n","content":"(**\n# F# For You!\n\nHang tight, we\u0027re still in the planning stages.\n\nIf you\u0027d like to contribute, go [here.](https://github.com/fsharpforyou/fsharpforyou.github.io)\n*)"},{"uri":"/contributing.html","title":"Contributing","content":"(**\n---\ntitle: Contributing\ncategory: Contributing\ncategoryindex: 99\nindex: 1\n---\n*)\n\n(**\n# Contributing to this project\n\nThis project was started to create a guide for new and/or inexperienced programmers using \u0060F#\u0060.\n\nOur repository lives at: https://github.com/fsharpforyou/fsharpforyou.github.io\n\nWe use [\u0060FSharp.Formatting\u0060](https://fsprojects.github.io/FSharp.Formatting/) so we can write each page using literate \u0060F#\u0060 scripts.\n\nPrior art/inspirations/reference material:\n\n - [Learn You a Haskell for Great Good!](http://learnyouahaskell.com/)\n - [Clojure for the Brave and True](https://www.braveclojure.com/)\n - [OCaml Programming](https://cs3110.github.io/textbook/cover.html)\n - [The Rust Book](https://doc.rust-lang.org/stable/book/title-page.html)\n - And of course, the canonical [F# for Fun and Profit](https://fsharpforfunandprofit.com/)\n\n*)"},{"uri":"/introduction/installing.html","title":"Installing F#","content":"(**\n---\ntitle: Installing F#\ncategory: Introduction\ncategoryindex: 1\nindex: 1\n---\n*)\n\n(**\n# Installing F#\nFirst, you have to install \u0060.NET\u0060. Follow the directions here: https://dotnet.microsoft.com/en-us/download\n\nOnce you\u0027ve done that, you\u0027re done! You\u0027ve installed \u0060F#\u0060! Wow!\n\nFor editors, we recommend \u0060VS Code\u0060 with the \u0060Ionide\u0060 extension.\n\nYou\u0027re more than welcome to use any editor that strikes your fancy. Except maybe not Microsoft Word.\n*)\n\n\n(**\n## Our first program\nThere are a couple of ways we can run \u0060F#\u0060 code.\nTo open an interactive session where we can enter code and have it immediately evaluated,\nfire up your friendly local command prompt and type \u0060dotnet fsi\u0060.\nOnce you\u0027re jacked in, do the following:\n*)\n\nprintfn \u0022Hello world!\u0022;;\n\n(**\nIncredible. Do you feel the power coursing through your veins?\n\nType a few more things just to get your adrenaline flowing.\n\nMake sure to include the \u0060;;\u0060 at the end. This won\u0027t be required in\nregular \u0060F#\u0060 code, but is important to tell the interactive session\nwe\u0027re ready to be evaluated.\n*)\n\nlet numbers = [ 0..99 ];;\n(*** include-value: numbers ***)\n\nList.sum numbers;;\n(*** include-it ***)\n\n(**\nTo exit the interpreter, type \u0060#quit;;\u0060 and hit enter.\n*)"},{"uri":"/basics/fundamental_types.html","title":"Fundamental Types","content":"(**\n---\ntitle: Fundamental Types\ncategory: Basics\ncategoryindex: 2\nindex: 2\n---\n*)\n\n(**\n# Fundamental Types\n\n## Primitives Types\n\u0060\u0060int\u0060\u0060: Represents numerical values from \u0060\u0060-2,147,483,648\u0060\u0060 to \u0060\u00602,147,483,647\u0060\u0060.  \n\u0060\u0060float\u0060\u0060: Represents a floating point numerical value. Possible values range from: \u0060\u0060-1.79769313486232e308\u0060\u0060 to \u0060\u00601.79769313486232e308\u0060\u0060.    \n\u0060\u0060bool\u0060\u0060: Represents a \u0060\u0060True\u0060\u0060 or \u0060\u0060false\u0060\u0060 value.  \n\u0060\u0060char\u0060\u0060: Represents a unicode character value.  \n\u0060\u0060string\u0060\u0060: Represents a sequence of \u0060\u0060char\u0060\u0060s (unicode text).\n*)\n\nlet integer = 1\nlet float = 1.0\nlet bool = true\nlet char = \u0027a\u0027\nlet string = \u0022abcdefg\u0022\n(*** include-fsi-output ***)\n\n(**\n## Tuples\nTuples are a finite ordered sequence of comma-separated values of differing types.\nThe length and types of a tuple are known at compile-time and are present in its type signature.\n*)\n\nlet coordinates = (1.0, 2.0, 3.0)\n(*** include-fsi-output ***)\n\n(**\n## Unit type\nSince every expression in F# must evaluate to a value,\nthe unit type is used when no other value of interest exists.\nThe unit type only has a single value: \u0060\u0060()\u0060\u0060\n*)\n\n()\n(*** include-fsi-output ***)\n\n(**\nOften times, functions that perform an operation and don\u0027t have a useful value to return will instead return a unit value. \n*)\nprintfn \u0022Hello, World!\u0022\n(*** include-fsi-output ***)\n"},{"uri":"/basics/basic_operators.html","title":"Basic Operators","content":"(**\n---\ntitle: Basic Operators\ncategory: Basics\ncategoryindex: 2\nindex: 3\n---\n*)\n\n(**\n# Operators\nOperators are special functions that take one or more values and yield another value.\n\n### Arithmetic Operators:\nArithmetic operators are concerned with mathematical operations such as \u0060\u0060add\u0060\u0060, \u0060\u0060subtract\u0060\u0060, \u0060\u0060multiply\u0060\u0060, \u0060\u0060divide\u0060\u0060,\nand yield the result of such operations.  \n\u0060\u0060\u002B\u0060\u0060: add two numbers  \n\u0060\u0060-\u0060\u0060: subtract two numbers  \n\u0060\u0060*\u0060\u0060: multiply two numbers  \n\u0060\u0060/\u0060\u0060: divide two numbers  \n\u0060\u0060**\u0060\u0060: power  \n\u0060\u0060%\u0060\u0060: modulo (remainder after the division of two numbers)  \n*)\nlet addition = 5 \u002B 2 // 5 plus 2\nlet subtraction = 5 - 2 // 5 minus 2\nlet multiplication = 5 * 2 // 5 times 2\nlet division = 5 / 2 // 5 divided by 2\nlet modulo = 5 % 2 // the remainder of 5 divided by 2\nlet exponent = 5.0 ** 2.0 // 5 to the power of 2\n(*** include-fsi-output ***)\n\n(**\n### Logical operators:\nLogical operators perform comparison operations on two values and yield boolean (true or false) values.\nExample: \u0060\u0060is ... equal to ...\u0060\u0060 or \u0060\u0060is ... greater then ...\u0060\u0060  \n\n\u0060\u0060=\u0060\u0060: equality  \n\u0060\u0060\u003C\u003E\u0060\u0060: inequality  \n\u0060\u0060\u003C\u0060\u0060: less than  \n\u0060\u0060\u003E\u0060\u0060: greater than  \n\u0060\u0060\u003C=\u0060\u0060: less than or equal to  \n\u0060\u0060\u003E=\u0060\u0060: greater than or equal to  \n\u0060\u0060\u0026\u0026\u0060\u0060: logical OR  \n\u0060\u0060||\u0060\u0060: logical AND  \n\u0060\u0060not\u0060\u0060: logical NOT, negates a boolean value.  \n*)\nlet equals = 5 = 5 // is 5 equal to 5\nlet notEquals = 5 \u003C\u003E 5 // is 5 NOT equal to 5\nlet lessThan = 5 \u003C 5 // is 5 less than 5\nlet greaterThan = 5 \u003E 5 // is 5 greater than 5\nlet lessThanOrEqualTo = 5 \u003C= 5 // is 5 less than or equal to 5\nlet greaterThanOrEqualTo = 5 \u003E= 5 // is 5 greater than or equal to 5\nlet logicalAnd = 5 = 5 \u0026\u0026 6 = 6 // is 5 equal to 5 AND 6 equal to 6\nlet logicalOr = 5 = 5 || 6 = 7 // is 5 equal to 5 OR six equal to 7\nlet falseValue = not (true) // true -\u003E false\nlet trueValue = not (false) // false -\u003E true\n(*** include-fsi-output ***)"},{"uri":"/basics/collections.html","title":"Collections","content":"(**\n---\ntitle: Collections\ncategory: Basics\ncategoryindex: 2\nindex: 5\n---\n*)\n\n(**\n# Collections\nCollections represent a finite series of elements of the same type.\nThere are different types of collections in F#, including: Lists, Arrays, and Sequences\n\nLists: Lists are an immutable series of elements implemented as singly linked list.  \nArrays: Arrays are a fixed-size mutable series of elements.  \nSequences: Sequences are an immutable series of elements. Unlike arrays and lists, the elements\nof a sequence are only computed/evaluated when it is required to do so.\n\n## Lists\nYou can define a list by surrounding a semicolon separated sequence of values surrounded by square brackets like so:\n*)\n\nlet list = [1; 2; 3; 4; 5]\n(*** include-fsi-output ***)\n\n(**\nYou can access individual values of a list through its indexer.\nIn F#, collections are indexed by 0, which means the first element has an index of 0, the second element has an index of 1, and so on...\n*)\nlet firstElement = list[0]\n(*** include-fsi-output ***)\n\n(**\nYou can also access a subsequence of values using a range.\nYou can create a range by defining the lower bound and upper bound separated by two periods like so:\n*)\nlet threeElements = list[0..2]\n(*** include-fsi-output ***)\n\n(**\nAs you can see from the above example, every element from index 0 to 2 is present in the new list.\n\nNot only can you index a specified range, but you can also construct a list with every element in\na specified range like so: \n*)\n\nlet numbers = [0..10]\n(*** include-fsi-output ***)\n\n(**\nRanges can also have a \u0022step amount\u0022 which dictates how many steps are taken from one element to the next.\nA range of \u0060\u0060[0..10]\u0060\u0060 with a step amount of 2 will produce even numbers.\nThe first element is 0 then the next element will be 2... and so on.\nWe can define a step amount by inserting it between the lower and upper bound like so:\n*)\n\nlet evenNumbers = [ 0 .. 2 .. 10 ]\n(*** include-fsi-output ***)\n\n(**\nYou can use the CONS operator (\u0060\u0060::\u0060\u0060) to add an element to the beginning of a list.\nAs lists are immutable, any \u0022modification\u0022 won\u0027t modify the original list, but instead will return a\nnew list with the appropriate changes.\n*)\nlet integers = [1;2;3;4;5]\nlet integers2 = 0 :: integers\n(*** include-fsi-output ***)\n\n(**\nIf you wanted to append not only an element, but an entire list to the beginning of another,\nyou would use the \u0060\u0060@\u0060\u0060 operator instead like so:\n*)\nlet integers3 = [1;2;3;4;5]\nlet integers4 = integers @ [6;7;8;9;10]\n(*** include-fsi-output ***)\n\n(**\nYou can use for comprehension to build a list from a \u0060\u0060for\u0060\u0060 expression like so:\n*)\nlet doubles = [for i in 0..10 -\u003E i * 2]\n(*** include-fsi-output ***)\n\n(**\nThis reads as: \u0060\u0060for\u0060\u0060 every element in the sequence \u0060\u00600..10\u0060\u0060,\nbind the current element to the name \u0060\u0060i\u0060\u0060, and yield the value \u0060\u0060i * 2\u0060\u0060\n\n### List module functions\nThe list module has useful functions for working with lists.\nSome of these functions include:  \n\u0060\u0060filter\u0060\u0060 which will filter elements from a list using a conditional value,  \n\u0060\u0060map\u0060\u0060 which will map every element in a list to a new element,  \n\u0060\u0060iter\u0060\u0060 which allows you to call a function with every element in a list,  \nand many more.\n*)\nlet nums = [0..10]\n(*** include-value: nums ***)\n\nlet filteredNums = List.filter (fun number -\u003E number \u003E 5) nums\n(*** include-value: filteredNums ***)\n\nlet doubledFilteredNums = List.map (fun number -\u003E number * 2) filteredNums\n(*** include-value: doubledFilteredNums ***)\n\n(**\n## Arrays\nArrays and lists have very similar construction syntax, however, the square brackets are\naccompanied by a vertical bar.\n*)\nlet array = [| 1;2;3;4;5 |]\n(*** include-fsi-output ***)\n\n(**\nUnlike lists, you can mutate individual elements in an array by using its indexer.\n*)\narray[0] \u003C- 10\n(*** include-value: array ***)\n\n\n(**\n## Sequences\nSequences are constructed using a Computation Expression (you\u0027ll learn about these later).\nSome examples of sequence expressions are as follows:\n*)\nlet numsSequence = seq { 1..10 }\nlet doublesSequence = seq { for i in 0..10 -\u003E i * 2 }\n\n(**\nAs noted in the beginning, the elements of a sequence aren\u0027t computed when the sequence is created. They are only computed\nwhen the value is required to perform a certain operation.\n*)\nlet sequence = seq { 0..10 }\nSeq.head sequence\n(*** include-fsi-output ***)\n\n(**\nAs you can see from the above example, the first element of the sequence is computed as a result of calling \u0060\u0060Seq.head\u0060\u0060.\nAny further call to \u0060\u0060Seq.head\u0060\u0060 will use the already evaluated value. No further evaluation of the first element is required.\n*)"},{"uri":"/basics/values.html","title":"Values and expressions","content":"(**\n---\ntitle: Values and expressions\ncategory: Basics\ncategoryindex: 2\nindex: 1\n---\n*)\n\n(**\n# Values and expressions\nIn this chapter, we\u0027ll be going over expressions and values in F#.\n\nWhat exactly is an expression?\nAn expression is a block of code that produces a value.\n\nLet\u0027s take a quick look at this expression:\n*)\n\n5 \u002B 5\n(*** include-fsi-output ***)\n\n(**\nLet\u0027s break that down:\n\n 1. \u0060\u00605 \u002B 5\u0060\u0060 is an expression.\n 2. The expression evaluates to \u0060\u006010\u0060\u0060\n 3. The value has the type of \u0060\u0060int\u0060\u0060\n\nWhat does this mean?\n\n -   F# is an expression-based language which means that everything is a value.\n     This differs from languages that make a distinction between expressions (yielding values)\n     and statements (commands).\n\n -   F# is a strongly, statically typed language which means that every value has a single type\n     which can\u0027t be changed after initialization.\n\n## Let bindings\nWe can assign values to names using let bindings:\n*)\n\nlet ten = 5 \u002B 5\n(*** include-fsi-output ***)\n\n(**\nFrom left to right, this reads as:\n\u0060\u0060let\u0060\u0060 the name \u0060\u0060ten\u0060\u0060 be assigned to the result of the expression \u0060\u00605 \u002B 5\u0060\u0060.\n\nAs you may have noticed, the binding\u0027s type is inferred by the compiler.\nF# has strong type inference which means that values usually don\u2019t require type annotations.\nAlthough, type annotations are needed if the compiler can\u0027t figure out the type for a value,\nor you want to override the compiler\u2019s type inference.\n\nYou can specify type annotations by using a colon followed by the value\u0027s type like so:\n*)\n\nlet five: float = 5\n(*** include-fsi-output ***)\n\n(**\nBy default let bindings are immutable which means their values can\u2019t be changed after initialization.\nF# does support mutable let bindings, but we have to explicitly declare that a binding is mutable using the \u0060\u0060mutable\u0060\u0060 keyword and mutate it using the \u0060\u0060\u003C-\u0060\u0060 operator.\n*)\n\nlet mutable result = 1 \u002B 1\nresult \u003C- 4\n(*** include-fsi-output ***)\n\n(**\n## Type safety\nAs noted above, F# is a statically, strongly typed language which means that every value has a single type and we are unable to change that type after initialization.\nThis allows us to write code with confidence as every value\u0027s type is checked at compile-time and is guaranteed to be correct or our application won\u0027t compile.\n\nBecause the value of \u0060result\u0060 has the type of \u0060\u0060int\u0060\u0060, we cannot change the binding to a value with the type of \u0060string\u0060. This code will result in a compiler error:\n\u0060\u0060\u0060fsharp\nlet mutable result = 1 \u002B 1\nresult \u003C- \u0022Hello\u0022\n\u0060\u0060\u0060\n\u0060\u0060\u0060text\nThis expression was expected to have type\n    \u0027int\u0027\nbut here has type\n    \u0027string\u0027\n\u0060\u0060\u0060\n*)"},{"uri":"/basics/conditionals.html","title":"Conditionals","content":"(**\n---\ntitle: Conditionals\ncategory: Basics\ncategoryindex: 2\nindex: 7\n---\n*)\n\n(**\n# Conditional Expressions\nConditional expressions are expressions that evaluate a boolean value (true or false)\nand evaluate a branch of code if that condition yields a \u0060\u0060true\u0060\u0060 value: \u0060\u0060if X do Y, else do Z\u0060\u0060\n*)\n\nlet outputAge age =\n  if age \u003E= 18 then printfn \u0022You are an adult!\u0022\n  else printfn \u0022You are not an adult!\u0022\n\noutputAge 23\noutputAge 15\n(*** include-output ***)\n\n(**\nAll branches of a conditional expression must return values of the same type, which is inferred from the return value of the first branch (or optionally, the type annotation).\nIf the first branch returns a \u0060\u0060string\u0060\u0060 value, the second branch cannot return a \u0060\u0060unit\u0060\u0060 value as \u0060\u0060unit\u0060\u0060 is not convertible to \u0060\u0060string\u0060\u0060.\nThis code will result in a compiler error:\n\u0060\u0060\u0060fsharp\nlet outputAge\u0027 age =\n  if age \u003E= 18 then \u0022Adult\u0022 // \u003C- string value\n  else () // \u003C- unit value\n\u0060\u0060\u0060\n*)"},{"uri":"/basics/pattern_matching.html","title":"Pattern Matching","content":"(**\n---\ntitle: Pattern Matching\ncategory: Basics\ncategoryindex: 2\nindex: 8\n---\n*)\n\n(**\n# Pattern matching\nPattern matching allows us to decompose and deconstruct types such as Unions, Records, and Tuples based on their shape and values using patterns,\nwhich act as rules for their transformation. Let\u0027s start with tuple patterns so we could start to understand this concept and why it\u0027s so powerful.\n\nLet\u0027s start by decomposing a coordinate tuple into its respective \u0060\u0060x, y, z\u0060\u0060 bindings.\n*)\n\nlet coordinate = 3, 5, 1\nlet x, y, z = coordinate\n(*** include-fsi-output ***)\n\n(**\nBecause the signature of \u0060\u0060coordinate\u0060\u0060 is \u0060\u0060int * int * int\u0060\u0060 the pattern \u0060\u0060x, y, z\u0060\u0060\ndefines individual bindings for each position of the tuple.\nThe first tuple element will be deconstructed into \u0060\u0060x\u0060\u0060, the second into \u0060\u0060y\u0060\u0060, and the third into \u0060\u0060z\u0060\u0060 because of their positions in the pattern.\n\nTo expand on this coordinate example, we can create a discriminated union\nthat represents a choice between a two-dimensional or three-dimensional coordinate value.\n\n\u0060\u0060\u0060fsharp\ntype Coordinate =\n    | Coord2d of int * int\n    | Coord3d of int * int * int\n\u0060\u0060\u0060\n\nNow that we\u0027ve done this, how could we determine whether a coordinate value is either two-dimensional or three-dimensional?\nWe could utilize a match expression to do this. A match expression will allow us to define multiple patterns which will\nbe evaluated against the value in order. Once a pattern is matched, the expression associated with that match arm will be evaluated.\n*)\n\ntype Coordinate =\n    | Coord2d of int * int\n    | Coord3d of int * int * int\n\nlet details coord =\n    match coord with\n    | Coord2d (x, y) -\u003E printfn $\u0022two-dimensional coordinate value. X: {x}, Y: {y}\u0022\n    | Coord3d (x, y, z) -\u003E printfn $\u0022three-dimensional coordinate value. X: {x}, Y: {y}, Z: {z}\u0022\n\nlet coord2d = Coord2d(5, 10)\nlet coord3d = Coord3d(1, 5, 10)\n\ndetails coord2d\ndetails coord3d\n(*** include-output ***)\n\n(**\nAs you can see from the above example, we can define multiple match arms each with their own pattern.\nWe match against a Discriminated Union by matching against the choice, and optionally, the data associated with it.\nBecause we\u0027re simply deconstructing the data, the arm will always be matched against if the choice is correct.\n\nHowever, we can define multiple patterns for a single choice, by additionally matching against the data associated with it.\n*)\nlet zero coordinates =\n    match coordinates with\n    // if the identifier is Coord2 and the tuple is (0, 0)\n    | Coord2d (0, 0) -\u003E true\n    // if the identifier is Coord3 and the tuple is (0, 0, 0)\n    | Coord3d (0, 0, 0) -\u003E true\n    | Coord2d (x, y) -\u003E false\n    | Coord3d (x, y, z) -\u003E false\n(**\nHere, instead of just defining a pattern that matches a discriminated union\u0027s identifier,\nwe can match against a discriminated union\u0027s identifier AND the value associated with it.\nIf the choice is \u0060\u0060Coord2d\u0060\u0060 and the tuple value is \u0060\u00600.0, 0.0\u0060\u0060 then the first arm will be matched against... and so on.\nThis is called a \u0060\u0060constant\u0060\u0060 pattern. Where we match a value against a constant value (constant values are: strings, numerical values, and enumerations).\nExample: Matching a value of type \u0060\u0060int * int * int\u0060\u0060 against a constant pattern of \u0060\u0060(0, 1, 2)\u0060\u0060\nIf each tuple value is equal to the corresponding constant value in the same position, the pattern will be matched.\n\nMatch expressions need to be exhaustive, which means that every possible pattern needs to be accounted for. We\u0027ll get a compiler warning otherwise.\nIn some cases, this can be tedious (or impossible). Often times we only want to match against a few patterns and discard the rest.\nWe can do this using the wildcard pattern, identified by an underscore as shown below:\n*)\n\nlet zero\u0027 coordinates =\n    match coordinates with\n    | Coord2d (0, 0) -\u003E true\n    | Coord3d (0, 0, 0) -\u003E true\n    | Coord2d _ -\u003E false // effectively ignores the data associated with this DU identifier\n    | Coord3d _ -\u003E false // effectively ignores the data associated with this DU identifier\n\n(**\nAs you can see from the above example, we don\u0027t necessarily care about the data associated with the identifier in the last two cases, so we just ignore it.\n\nHowever, this code can still be improved, the first two and the last two patterns evaluate to the same value.\n\u0060\u0060if the first OR second pattern matches then ...\u0060\u0060 and \u0060\u0060if the third OR fourth pattern matches then ...\u0060\u0060.\nWe could simplify this code by using the OR pattern like so:\n*)\nlet zero\u0027\u0027 coordinates =\n    match coordinates with\n    | Coord2d (0, 0)\n    | Coord3d (0, 0, 0) -\u003E true\n    | Coord2d _\n    | Coord3d _ -\u003E false\n\n(**\nAs you can see from the above example, we can define one resulting expression for multiple patterns.\nIf any of the patterns match against the value, then that shared expression will be evaluated.\n\nSometimes, we just want to deal with the value directly in a match arm. We could do this using the variable pattern.\nThe variable pattern creates a binding from the value we\u0027re matching against to a specific name.\nYou can also use the variable pattern in conjunction with a \u0060\u0060when\u0060\u0060 expression for conditional logic.\n*)\n\nlet matchValue value =\n    match value with\n    | value when value \u003E 5 -\u003E $\u0022{value} is greater than 5\u0022\n    | value -\u003E sprintf $\u0022Value is {value}\u0022\n\nlet matchWithTen = matchValue 10\nlet matchWithTwo = matchValue 2\n(*** include-fsi-output ***)\n\n(**\nWe can decompose records and match against their values using a record pattern.\n*)\ntype Coords = { X: int; Y: int; Z: int }\n\nlet matchCoords coords =\n    match coords with\n    | { X = 0; Y = 0; Z = 0 } -\u003E printfn \u0022X, Y, and Z are all 0\u0022\n    | { X = x; Y = y; Z = z } -\u003E printfn $\u0022X: {x}, Y: {y}, Z: {z}\u0022\n\nmatchCoords { X = 0; Y = 0; Z = 0 }\nmatchCoords { X = 10; Y = 20; Z = 30 }\n(*** include-output ***)\n\n(**\nAs you can see from the above example,\nthe pattern \u0060\u0060{ X = 0; Y = 0; Z = 0 }\u0060\u0060 will match against any record definition with the corresponding values and\nthe pattern \u0060\u0060{ X = x; Y = y; Z = z }\u0060\u0060 will deconstruct the record values into individual bindings.\n\nWe can decompose a list using the list pattern like so:\n*)\n\nlet outputList list =\n    match list with\n    | [ 1 ] -\u003E printfn \u0022Single value: 1\u0022\n    | [ 1; 2 ] -\u003E printfn \u0022Two values: 1 and 2\u0022\n    | [ 1; 2; 3 ] -\u003E printfn \u0022Three values: 1, 2, and 3\u0022\n    | [ x; y; z ] -\u003E printfn $\u0022Three values: {x}, {y}, and {z}\u0022\n\noutputList [1]\noutputList [1; 2]\noutputList [1; 2; 3]\noutputList [0; 10; 20]\n(*** include-output ***)\n\n(**\nYou can use the CONS pattern (\u0060\u0060::\u0060\u0060) to deconstruct a list into its head and tail values like so:\n*)\nlet outputList\u0027 list =\n    match list with\n    | [] -\u003E printfn \u0022List is empty.\u0022\n    | head :: tail -\u003E printfn $\u0022Head: {head}, Tail: %A{tail}\u0022\n\noutputList\u0027 []\noutputList\u0027 [1]\noutputList\u0027 [1;2;3;4;5]\n(*** include-output ***)\n\n(**\nAs you can see from the above example, if there is a single element present in the list\nthe first element will be assigned to the name \u0060\u0060head\u0060\u0060, and the tail of the list (the elements other then the head) will\nbe assigned to the name \u0060\u0060tail\u0060\u0060.\n\nThis pattern can be extended by using \u0060\u0060first :: second :: tail\u0060\u0060\nwhich will match any list that has 2 of more elements.\n*)\nlet outputList\u0027\u0027 list =\n    match list with\n    | [] -\u003E printfn \u0022List is empty.\u0022\n    | first :: second :: tail -\u003E printfn $\u0022First: {first}, Second: {second}, Tail: %A{tail}\u0022\n    | head :: tail -\u003E printfn $\u0022Head: {head}, Tail: %A{tail}\u0022\n\noutputList\u0027\u0027 [1]\noutputList\u0027\u0027 [1;2]\n(*** include-output ***)\n\n(**\nThis pattern can be extended to match a list with any number of elements like so:\n\u0060\u0060first :: second :: third :: fourth :: tail\u0060\u0060 and so on...\n*)"},{"uri":"/basics/creating_types.html","title":"Creating Types","content":"(**\n---\ntitle: Creating Types\ncategory: Basics\ncategoryindex: 2\nindex: 6\n---\n*)\n\n(**\n# Creating Types\nIn F#, you can create your own types. These include: type aliases, records, and discriminated unions.\n\n## Type Aliases\nType aliases allow you to create aliases for existing types.\n*)\n\ntype EmailAddress = string\n\n(**\nBecause \u0060\u0060EmailAddress\u0060\u0060 is an alias for \u0060\u0060string\u0060\u0060, for all intents and purposes an \u0060\u0060EmailAddress\u0060\u0060 is just a \u0060\u0060string\u0060\u0060, and can be used as such.\n*)\nlet emailAddressString: string = \u0022johndoe@email.com\u0022\nlet emailAddressAliased: EmailAddress = \u0022johndoe@gmail.com\u0022\n(*** include-fsi-output ***)\n\n(**\n## Record Types\nRecord types represent an immutable collection of named values.\n*)\ntype Person =\n    { FirstName: string\n      LastName: string\n      Age: int }\n\n(**\nYou can define records in multiple ways, for instance... another common syntax for record definition is a single-line definition with semicolon-separated members.\n(Semicolons can be used in any record definition, but they\u0027re only required for record definition if the members aren\u0027t on separate lines)\n*)\ntype Person\u0027 = { FirstName: string; LastName: string; Age: int }\n\n(**\nYou can construct a record value by giving each member of your desired record a value.\nThe type of the record is inferred from the members. As F# is evaluated top-down,\nthe compiler will infer the record type by using the record with matching members closest to the value declaration (if no type annotation is present).\n*)\n\ntype Customer =\n    { Username: string\n      EmailAddress: string\n      FullName: string }\n    \n let johnDoe =\n    { Username = \u0022john_doe\u0022\n      EmailAddress = \u0022johndoe@site.com\u0022\n      FullName = \u0022John Doe\u0022 }\n(*** include-fsi-output ***)\n\n(**\nRecords are immutable, which means their state can never be changed after a value is created.\nYou can copy the contents of a record, change individual members, and get a new value using the _copy and update_ expression.\n*)\ntype Coords =\n    { X: int\n      Y: int\n      Z: int }\n    \nlet coords = { X = 10; Y = 20; Z = 30 }\nlet updatedCoords = { coords with X = 0 }\n\nprintfn \u0022Coords: %O\u0022 coords\nprintfn \u0022Updated coords: %O\u0022 updatedCoords\n(*** include-output ***)\n\n(**\nAs you can see, \u0060\u0060updatedCoords\u0060\u0060 and \u0060\u0060coords\u0060\u0060 have the same \u0060\u0060Y\u0060\u0060 and \u0060\u0060Z\u0060\u0060 values.\nHowever, the \u0060\u0060X\u0060\u0060 value is different as that\u0027s the only value we changed in the _copy and update_ expression.\n\nYou can access individual members on a value using the dot operator as such:\n*)\nlet xValue = updatedCoords.X\n(*** include-value: xValue ***)\n\n(**\nBecause F# is evaluated top-down, types can\u0027t normally reference each other.\nHowever, you can define mutually recursive record types (records that reference each other) like so:\n*)\ntype Occupant =\n  { FirstName: string\n    LastName: string\n    Address: Address }\nand Address =\n  { State: string\n    City: string\n    StreetAddress: string\n    ZipCode: string\n    Occupant: Occupant }\n(*** include-fsi-output ***)\n\n(**\n## Discriminated Unions\nDiscriminated unions represent a choice between a number of named cases, optionally with additional data.\n*)\ntype Suit =\n  | Heart\n  | Diamond\n  | Club\n  | Spade\n\nlet suit = Heart\n(*** include-fsi-output ***)\n\n(**\nYou can define a choice\u0027s associated data by using \u0060\u0060of\u0060\u0060 followed by the value\u0027s type.\nIndividual cases can have different types of data associated with them, or no data at all.\n*)\ntype ContactInformation =\n  | EmailAddress of string\n  | PhoneNumber of string\n\nlet contactInfo = EmailAddress \u0022johndoe@email.com\u0022\n(*** include-fsi-output ***)"},{"uri":"/basics/piping_and_composition.html","title":"Piping and Composition","content":"(**\n---\ntitle: Piping and Composition\ncategory: Basics\ncategoryindex: 2\nindex: 9\n---\n*)\n\n\n(**\n## Piping\nPiping allows you to pass values into a function\u0027s or union\u0027s parameter and return the result.\nThis is often used when you\u0027re piping multiple function\u0027s and their results into each other.\n\nPassing a value of \u0060\u006010\u0060\u0060 into a function like so:\n\u0060\u0060\u0060fsharp\nfunction 10\n\u0060\u0060\u0060\n\nIs equivalent to piping that value into the function like so:\n\u0060\u0060\u0060fsharp\n10\n|\u003E function\n\u0060\u0060\u0060\n\nThis is really beneficial when you\u0027re dealing with \u0022long\u0022 function chains like so:\n\u0060\u0060\u0060fsharp\nlet f x = ...\nlet g x = ...\nlet m x = ...\n\nlet a = f 10\nlet b = g a\nlet c = m b\n\u0060\u0060\u0060\n\nUsing the pipe operator, the above example would be:\n\u0060\u0060\u0060fsharp\nlet f x = ...\nlet g x = ...\nlet m x = ...\n\n10\n|\u003E f\n|\u003E g\n|\u003E m\n\u0060\u0060\u0060\n\nA more practical example of the pipe operator in action is this:\n*)\nlet double x = x * 2\nlet isEven x = x % 2 = 0\n\nlet nums =\n    [0..20]\n    |\u003E List.map double // double every number\n    |\u003E List.filter isEven // only even numbers\n    |\u003E List.sortDescending // sort from high to low\n(*** include-value: nums ***)\n\n(**\n## Function Composition\n\nYou can compose multiple functions together using the \u0060\u0060\u003E\u003E\u0060\u0060 operator.\nThis allows you to evaluate the left-hand function and pass the result into the right-hand function.\nThe output type of the left-hand function must be the input type of the right hand function, example: \u0060\u0060A -\u003E B\u0060\u0060 and \u0060\u0060B -\u003E C\u0060\u0060.\nThis is very similar to piping, but instead of piping values into functions, we are building up new functions by combining smaller ones.\n*)\nlet addFive x = x \u002B 5\nlet multiplyTwo x = x * 2\nlet addFiveMultiplyTwo = addFive \u003E\u003E multiplyTwo\n\nlet twenty = addFiveMultiplyTwo 5\n(*** include-fsi-output ***)\n\n(**\nYou can chain these together to create new function by composing (or combining) many smaller functions\n*)\nlet addTwo x = x \u002B 2\nlet multiplyFive x = x * 5\nlet divideThree x = x / 3\nlet subtractFour x = x - 4\nlet operation = addTwo \u003E\u003E multiplyFive \u003E\u003E divideThree \u003E\u003E subtractFour\n\nlet sixteen = operation 10\n(*** include-fsi-output ***)"},{"uri":"/basics/functions.html","title":"Functions","content":"(**\n---\ntitle: Functions\ncategory: Basics\ncategoryindex: 2\nindex: 4\n---\n*)\n\n(**\n# Functions\nFunctions are the primary unit of execution of any program.\nThey serve as named bindings from a set of parameters to a value.\nUnlike let bindings, functions are evaluated once per call.\nYou can define function parameters one after another separated by a space.\nThese parameters will be passed into the function when it\u0027s called by the consumer.\n*)\nlet double x = x * 2\nlet add x y = x \u002B y\nlet multiply x y = x * y\n\nlet ten = double 5\nlet fifteen = add 10 5\nlet twenty = multiply 10 2\n(*** include-fsi-output ***)\n\n(**\nOptionally, you can add type annotations to a function parameter by surrounding the parameter with parenthesis and annotating it with the desired type.\nThe type annotation preceding the \u0060\u0060=\u0060\u0060 is the return type of the function.\n*)\nlet divide (left: int) (right: int) : int = left / right\nlet four = divide 8 2\n(*** include-fsi-output ***)\n\n(**\nSome functions won\u0027t take in a specific parameter but instead will have a unit parameter.\nThis acts as a zero parameter function.\n*)\n\nlet getInt () = 30\nlet thirty = getInt ()\n(*** include-fsi-output ***)\n\n(**\n## Currying and Function signatures\nIn F#, all functions are curried.\nThis means that every function has a single parameter.\nWhat about \u0060\u0060let add x y = ...\u0060\u0060, doesn\u0027t that have two parameters? \nIf we look at this function\u0027s signature, we could figure out what exactly is going on.\n*)\nlet addNumbers x y = x \u002B y\n(*** include-fsi-output ***)\n\n(**\nAs you can see from the above example, the function signature is \u0060\u0060int -\u003E int -\u003E int\u0060\u0060.\nWhat does this mean? A function with the signature of \u0060\u0060int -\u003E int\u0060\u0060 means the function has a single \u0060\u0060int\u0060\u0060 parameter\nand returns an \u0060\u0060int\u0060\u0060 value. The signature \u0060\u0060int -\u003E int -\u003E int\u0060\u0060 means the function has a single \u0060\u0060int\u0060\u0060 parameter, and returns\nanother function with the signature of \u0060\u0060int -\u003E int\u0060\u0060. Functions with \u0022multiple parameters\u0022 are instead functions with a single parameter\nthat return other functions.\n\nWe can see this by passing one argument to the \u0060\u0060addNumbers\u0060\u0060 function.\n*)\nlet addFive = addNumbers 5\n(*** include-fsi-output ***)\n\n(**\nThis is called partial application.\nWe can partially fill in parameters to a function and get a new function where only the remaining parameters need to be filled in.\nThis allows us to build new reusable functions from existing functions as shown above.\n*)\nlet fifty = addFive 45\n(*** include-fsi-output ***)\n\n(**\n## Passing functions around\nHigher order functions are functions that accept functions as parameters or return functions.\nThis can be very useful for abstracting away the implementation of a function (dynamic implementation).\n\nHere we will define a function named \u0060\u0060outputParameter\u0060\u0060 that will accept another function as a parameter.\n*)\nlet outputNumber (output: int -\u003E unit) = output 10 \n\n(**\nBecause \u0060\u0060printfn \u0022%d\u0022\u0060\u0060 returns a function with the signature of \u0060\u0060int -\u003E unit\u0060\u0060, we can pass it to the \u0060\u0060outputNumber\u0060\u0060 function.\n*)\nlet printNumber = printfn \u0022%d\u0022\noutputNumber printNumber\n(*** include-fsi-merged-output ***)\n\n(**\n## Anonymous functions\nAnonymous functions aka lambda expressions are a way to define functions without explicitly naming them.\nThis is often used in conjunction with higher-order functions (when passing functions as arguments to other functions).\n*)\n\noutputNumber (fun number -\u003E printfn \u0022%d\u0022 number)\n(*** include-output ***)"}]