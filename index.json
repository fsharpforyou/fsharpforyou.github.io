[{"uri":"/contributing.html","title":"Contributing","content":"(**\n---\ntitle: Contributing\ncategory: Contributing\ncategoryindex: 99\nindex: 1\n---\n*)\n\n(**\n# Contributing to this project\n\nThis project was started to create a guide for new and/or inexperienced programmers using \u0060F#\u0060.\n\nOur repository lives at: https://github.com/fsharpforyou/fsharpforyou.github.io\n\nWe use [\u0060FSharp.Formatting\u0060](https://fsprojects.github.io/FSharp.Formatting/) so we can write each page using literate \u0060F#\u0060 scripts.\n\nPrior art/inspirations/reference material:\n\n - [Learn You a Haskell for Great Good!](http://learnyouahaskell.com/)\n - [Clojure for the Brave and True](https://www.braveclojure.com/)\n - [OCaml Programming](https://cs3110.github.io/textbook/cover.html)\n - [The Rust Book](https://doc.rust-lang.org/stable/book/title-page.html)\n - And of course, the canonical [F# for Fun and Profit](https://fsharpforfunandprofit.com/)\n\n*)"},{"uri":"/index.html","title":"F# For You!\n","content":"(**\n# F# For You!\n\nHang tight, we\u0027re still in the planning stages.\n\nIf you\u0027d like to contribute, go [here.](https://github.com/fsharpforyou/fsharpforyou.github.io)\n*)"},{"uri":"/introduction/types.html","title":"Types","content":"(**\n---\ntitle: Types\ncategory: Introduction\ncategoryindex: 1\nindex: 3\n---\n*)\n\n(**\n# Types\nThis is just a placeholder for now.\n*)\n\nlet numbers = [ 0..99 ];;\n(*** include-value: numbers ***)\n\nList.sum numbers;;\n(*** include-it ***)"},{"uri":"/introduction/installing.html","title":"Installing F#","content":"(**\n---\ntitle: Installing F#\ncategory: Introduction\ncategoryindex: 1\nindex: 1\n---\n*)\n\n(**\n# Installing F#\nFirst, you have to install \u0060.NET\u0060. Follow the directions here: https://dotnet.microsoft.com/en-us/download\n\nOnce you\u0027ve done that, you\u0027re done! You\u0027ve installed \u0060F#\u0060! Wow!\n\nFor editors, we recommend \u0060VS Code\u0060 with the \u0060Ionide\u0060 extension.\n\nYou\u0027re more than welcome to use any editor that strikes your fancy. Except maybe not Microsoft Word.\n*)\n\n\n(**\n## Our first program\nThere are a couple of ways we can run \u0060F#\u0060 code.\nTo open an interactive session where we can enter code and have it immediately evaluated,\nfire up your friendly local command prompt and type \u0060dotnet fsi\u0060.\nOnce you\u0027re jacked in, do the following:\n*)\n\nprintfn \u0022Hello world!\u0022;;\n\n(**\nIncredible. Do you feel the power coursing through your veins?\n\nType a few more things just to get your adrenaline flowing.\n\nMake sure to include the \u0060;;\u0060 at the end. This won\u0027t be required in\nregular \u0060F#\u0060 code, but is important to tell the interactive session\nwe\u0027re ready to be evaluated.\n*)\n\nlet numbers = [ 0..99 ];;\n(*** include-value: numbers ***)\n\nList.sum numbers;;\n(*** include-it ***)\n\n(**\nTo exit the interpreter, type \u0060#quit;;\u0060 and hit enter.\n*)"},{"uri":"/introduction/values.html","title":"Values and expressions","content":"(**\n---\ntitle: Values and expressions\ncategory: Introduction\ncategoryindex: 1\nindex: 2\n---\n*)\n\n(**\n# Values and expressions\nIn this chapter, we\u0027ll be going over expressions and values in F#.\nLet\u0027s take a quick look at this expression:\n*)\n\n5 \u002B 5;;\n(*** include-it ***)\n\n(**\nLet\u0027s break that down:\n1. \u0060\u00605 \u002B 5\u0060\u0060 is an expression.\n2. The expression evaluates to \u0060\u006010\u0060\u0060\n3. The value has the type of \u0060\u0060int\u0060\u0060\nWhat does this mean?\n* F# is an expression-based language which means that _everything is a value_.\nThis differs from languages like C# and Java which make a distinction between expressions (yielding values)\nand statements (commands or units of execution).\n* F# is a statically typed language which means that every value has a single type that is\nenforced at compile time.\n\nWe can assign values to names using let bindings:\n*)\n\nlet ten = 5 \u002B 5;;\n(*** include-it ***)\n\n(**\nFrom left to right, this reads as:\n\u0060\u0060let\u0060\u0060 the name \u0060\u0060ten\u0060\u0060 be assigned to the result of the expression \u0060\u00605 \u002B 5\u0060\u0060.\n\nAs you may have noticed, the binding\u0027s type is inferred by the compiler.\nF# has strong type inference which means that values usually don\u2019t require type annotations.\nSometimes type annotations are needed if the compiler can\u0027t figure out the type for a specific value,\nor you want to override the compiler\u2019s type inference.\n\nYou can specify type annotations by using a colon followed by the value\u0027s type like so:\n*)\nlet five: int = 5\n(*** include-it ***)\n\n\n(**\nBy default let bindings are immutable which means their values can\u2019t be changed after initialization.\nF# does support mutable let bindings, but we have to explicitly declare that a binding is mutable.\nWe can declare a let binding as mutable using the \u0060\u0060mutable\u0060\u0060 keyword:\n*)\n\nlet mutable two = 1 \u002B 1;;\n(*** include-it ***)\n\n(**\nSince this binding is explicitly declared as mutable, we can then mutate its value using the \u2190 operator:\n*)\ntwo \u003C- 2\n\n(**\nAs previously stated, F# is a statically typed language with strong type safety.\nIf we try to change the value of a binding after initialization, we\u2019ll get a compiler error.\nBecause \u0060two\u0060 is declared as an \u0060int\u0060 value, we cannot change the binding to a value with the type of \u0060string\u0060.\n\nThis code will result in a compiler error:\n\u0060\u0060\u0060fsharp\ntwo \u003C- \u0022Hello\u0022\n\u0060\u0060\u0060\n\u0060\u0060\u0060\nerror FS0001: This expression was expected to have type\n    \u0027int\u0027\nbut here has type\n    \u0027string\u0027\n\u0060\u0060\u0060\n*)"}]