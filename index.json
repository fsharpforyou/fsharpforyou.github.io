[{"uri":"/index.html","title":"F# For You!\n","content":"(**\n# F# For You!\n\nHang tight, we\u0027re still in the planning stages.\n\nIf you\u0027d like to contribute, go [here.](https://github.com/fsharpforyou/fsharpforyou.github.io)\n*)"},{"uri":"/contributing.html","title":"Contributing","content":"(**\n---\ntitle: Contributing\ncategory: Contributing\ncategoryindex: 99\nindex: 1\n---\n*)\n\n(**\n# Contributing to this project\n\nThis project was started to create a guide for new and/or inexperienced programmers using \u0060F#\u0060.\n\nOur repository lives at: https://github.com/fsharpforyou/fsharpforyou.github.io\n\nWe use [\u0060FSharp.Formatting\u0060](https://fsprojects.github.io/FSharp.Formatting/) so we can write each page using literate \u0060F#\u0060 scripts.\n\nPrior art/inspirations/reference material:\n\n - [Learn You a Haskell for Great Good!](http://learnyouahaskell.com/)\n - [Clojure for the Brave and True](https://www.braveclojure.com/)\n - [OCaml Programming](https://cs3110.github.io/textbook/cover.html)\n - [The Rust Book](https://doc.rust-lang.org/stable/book/title-page.html)\n - And of course, the canonical [F# for Fun and Profit](https://fsharpforfunandprofit.com/)\n\n*)"},{"uri":"/introduction/installing.html","title":"Installing F#","content":"(**\n---\ntitle: Installing F#\ncategory: Introduction\ncategoryindex: 1\nindex: 1\n---\n*)\n\n(**\n# Installing F#\nFirst, you have to install \u0060.NET\u0060. Follow the directions here: https://dotnet.microsoft.com/en-us/download\n\nOnce you\u0027ve done that, you\u0027re done! You\u0027ve installed \u0060F#\u0060! Wow!\n\nFor editors, we recommend \u0060VS Code\u0060 with the \u0060Ionide\u0060 extension.\n\nYou\u0027re more than welcome to use any editor that strikes your fancy. Except maybe not Microsoft Word.\n*)\n\n\n(**\n## Our first program\nThere are a couple of ways we can run \u0060F#\u0060 code.\nTo open an interactive session where we can enter code and have it immediately evaluated,\nfire up your friendly local command prompt and type \u0060dotnet fsi\u0060.\nOnce you\u0027re jacked in, do the following:\n*)\n\nprintfn \u0022Hello world!\u0022;;\n\n(**\nIncredible. Do you feel the power coursing through your veins?\n\nType a few more things just to get your adrenaline flowing.\n\nMake sure to include the \u0060;;\u0060 at the end. This won\u0027t be required in\nregular \u0060F#\u0060 code, but is important to tell the interactive session\nwe\u0027re ready to be evaluated.\n*)\n\nlet numbers = [ 0..99 ];;\n(*** include-value: numbers ***)\n\nList.sum numbers;;\n(*** include-it ***)\n\n(**\nTo exit the interpreter, type \u0060#quit;;\u0060 and hit enter.\n*)"},{"uri":"/basics/types.html","title":"Types","content":"(**\n---\ntitle: Types\ncategory: Basics\ncategoryindex: 2\nindex: 2\n---\n*)\n\n(**\n# Types\nThis is just a placeholder for now.\n*)\n\nlet numbers = [ 0..99 ];;\n(*** include-value: numbers ***)\n\nList.sum numbers;;\n(*** include-it ***)"},{"uri":"/basics/values.html","title":"Values and expressions","content":"(**\n---\ntitle: Values and expressions\ncategory: Basics\ncategoryindex: 2\nindex: 1\n---\n*)\n\n(**\n# Values and expressions\nIn this chapter, we\u0027ll be going over expressions and values in F#.\n\nWhat exactly is an expression?\nAn expression is a block of code that produces a value.\n\nLet\u0027s take a quick look at this expression:\n*)\n\n5 \u002B 5\n(*** include-fsi-output ***)\n\n(**\nLet\u0027s break that down:\n\n 1. \u0060\u00605 \u002B 5\u0060\u0060 is an expression.\n 2. The expression evaluates to \u0060\u006010\u0060\u0060\n 3. The value has the type of \u0060\u0060int\u0060\u0060\n\nWhat does this mean?\n\n -   F# is an expression-based language which means that everything is a value.\n     This differs from languages that make a distinction between expressions (yielding values)\n     and statements (commands).\n\n -   F# is a strongly, statically typed language which means that every value has a single type\n     which can\u0027t be changed after initialization.\n\n## Let bindings\nWe can assign values to names using let bindings:\n*)\n\nlet ten = 5 \u002B 5\n(*** include-fsi-output ***)\n\n(**\nFrom left to right, this reads as:\n\u0060\u0060let\u0060\u0060 the name \u0060\u0060ten\u0060\u0060 be assigned to the result of the expression \u0060\u00605 \u002B 5\u0060\u0060.\n\nAs you may have noticed, the binding\u0027s type is inferred by the compiler.\nF# has strong type inference which means that values usually don\u2019t require type annotations.\nAlthough, type annotations are needed if the compiler can\u0027t figure out the type for a value,\nor you want to override the compiler\u2019s type inference.\n\nYou can specify type annotations by using a colon followed by the value\u0027s type like so:\n*)\n\nlet five: float = 5\n(*** include-fsi-output ***)\n\n(**\nBy default let bindings are immutable which means their values can\u2019t be changed after initialization.\nF# does support mutable let bindings, but we have to explicitly declare that a binding is mutable using the \u0060\u0060mutable\u0060\u0060 keyword and mutate it using the \u0060\u0060\u003C-\u0060\u0060 operator.\n*)\n\nlet mutable result = 1 \u002B 1\nresult \u003C- 4\n(*** include-fsi-output ***)\n\n(**\n## Type safety\nAs noted above, F# is a statically, strongly typed language which means that every value has a single type and we are unable to change that type after initialization.\nThis allows us to write code with confidence as every value\u0027s type is checked at compile-time and is guaranteed to be correct or our application won\u0027t compile.\n\nBecause the value of \u0060result\u0060 has the type of \u0060\u0060int\u0060\u0060, we cannot change the binding to a value with the type of \u0060string\u0060. This code will result in a compiler error:\n\u0060\u0060\u0060fsharp\nlet mutable result = 1 \u002B 1\nresult \u003C- \u0022Hello\u0022\n\u0060\u0060\u0060\n\u0060\u0060\u0060text\nThis expression was expected to have type\n    \u0027int\u0027\nbut here has type\n    \u0027string\u0027\n\u0060\u0060\u0060\n*)"}]