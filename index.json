[{"uri":"/index.html","title":"F# For You!\n","content":"(**\n# F# For You!\n\nHang tight, we\u0027re still in the planning stages.\n\nIf you\u0027d like to contribute, go [here.](https://github.com/fsharpforyou/fsharpforyou.github.io)\n*)"},{"uri":"/contributing.html","title":"Contributing","content":"(**\n---\ntitle: Contributing\ncategory: Contributing\ncategoryindex: 99\nindex: 1\n---\n*)\n\n(**\n# Contributing to this project\n\nThis project was started to create a guide for new and/or inexperienced programmers using \u0060F#\u0060.\n\nOur repository lives at: https://github.com/fsharpforyou/fsharpforyou.github.io\n\nWe use [\u0060FSharp.Formatting\u0060](https://fsprojects.github.io/FSharp.Formatting/) so we can write each page using literate \u0060F#\u0060 scripts.\n\nPrior art/inspirations/reference material:\n\n - [Learn You a Haskell for Great Good!](http://learnyouahaskell.com/)\n - [Clojure for the Brave and True](https://www.braveclojure.com/)\n - [OCaml Programming](https://cs3110.github.io/textbook/cover.html)\n - [The Rust Book](https://doc.rust-lang.org/stable/book/title-page.html)\n - And of course, the canonical [F# for Fun and Profit](https://fsharpforfunandprofit.com/)\n\n*)"},{"uri":"/introduction/installing.html","title":"Installing F#","content":"(**\n---\ntitle: Installing F#\ncategory: Introduction\ncategoryindex: 1\nindex: 1\n---\n*)\n\n(**\n# Installing F#\nFirst, you have to install \u0060.NET\u0060. Follow the directions here: https://dotnet.microsoft.com/en-us/download\n\nOnce you\u0027ve done that, you\u0027re done! You\u0027ve installed \u0060F#\u0060! Wow!\n\nFor editors, we recommend \u0060VS Code\u0060 with the \u0060Ionide\u0060 extension.\n\nYou\u0027re more than welcome to use any editor that strikes your fancy. Except maybe not Microsoft Word.\n*)\n\n\n(**\n## Our first program\nThere are a couple of ways we can run \u0060F#\u0060 code.\nTo open an interactive session where we can enter code and have it immediately evaluated,\nfire up your friendly local command prompt and type \u0060dotnet fsi\u0060.\nOnce you\u0027re jacked in, do the following:\n*)\n\nprintfn \u0022Hello world!\u0022;;\n\n(**\nIncredible. Do you feel the power coursing through your veins?\n\nType a few more things just to get your adrenaline flowing.\n\nMake sure to include the \u0060;;\u0060 at the end. This won\u0027t be required in\nregular \u0060F#\u0060 code, but is important to tell the interactive session\nwe\u0027re ready to be evaluated.\n*)\n\nlet numbers = [ 0..99 ];;\n(*** include-value: numbers ***)\n\nList.sum numbers;;\n(*** include-it ***)\n\n(**\nTo exit the interpreter, type \u0060#quit;;\u0060 and hit enter.\n*)"},{"uri":"/basics/fundamental_types.html","title":"Fundamental Types","content":"(**\n---\ntitle: Fundamental Types\ncategory: Basics\ncategoryindex: 2\nindex: 2\n---\n*)\n\n(**\n# Fundamental Types\n\n## Primitives Types\n\u0060\u0060int\u0060\u0060: Represents numerical values from \u0060\u0060-2,147,483,648\u0060\u0060 to \u0060\u00602,147,483,647\u0060\u0060.  \n\u0060\u0060float\u0060\u0060: Represents a floating point numerical value. Possible values range from: \u0060\u0060-1.79769313486232e308\u0060\u0060 to \u0060\u00601.79769313486232e308\u0060\u0060.    \n\u0060\u0060bool\u0060\u0060: Represents a \u0060\u0060True\u0060\u0060 or \u0060\u0060false\u0060\u0060 value.  \n\u0060\u0060char\u0060\u0060: Represents a unicode character value.  \n\u0060\u0060string\u0060\u0060: Represents a sequence of \u0060\u0060char\u0060\u0060s (unicode text).\n*)\n\nlet integer = 1\nlet float = 1.0\nlet bool = true\nlet char = \u0027a\u0027\nlet string = \u0022abcdefg\u0022\n(*** include-fsi-output ***)\n\n(**\n## Tuples\nTuples are a finite ordered sequence of comma-separated values of differing types.\nThe length and types of a tuple are known at compile-time and are present in its type signature.\n*)\n\nlet coordinates = (1.0, 2.0, 3.0)\n(*** include-fsi-output ***)\n\n(**\n## Unit type\nSince every expression in F# must evaluate to a value,\nthe unit type is used when no other value of interest exists.\nThe unit type only has a single value: \u0060\u0060()\u0060\u0060\n*)\n\n()\n(*** include-fsi-output ***)\n\n(**\nOften times, functions that perform an operation and don\u0027t have a useful value to return will instead return a unit value. \n*)\nprintfn \u0022Hello, World!\u0022\n(*** include-fsi-output ***)\n"},{"uri":"/basics/basic_operators.html","title":"Basic Operators","content":"(**\n---\ntitle: Basic Operators\ncategory: Basics\ncategoryindex: 2\nindex: 3\n---\n*)\n\n(**\n# Operators\nOperators are special functions that take one or more values and yield another value.\n\n### Arithmetic Operators:\nArithmetic operators are concerned with mathematical operations such as \u0060\u0060add\u0060\u0060, \u0060\u0060subtract\u0060\u0060, \u0060\u0060multiply\u0060\u0060, \u0060\u0060divide\u0060\u0060,\nand yield the result of such operations.  \n\u0060\u0060\u002B\u0060\u0060: add two numbers  \n\u0060\u0060-\u0060\u0060: subtract two numbers  \n\u0060\u0060*\u0060\u0060: multiply two numbers  \n\u0060\u0060/\u0060\u0060: divide two numbers  \n\u0060\u0060**\u0060\u0060: power  \n\u0060\u0060%\u0060\u0060: modulo (remainder after the division of two numbers)  \n*)\nlet addition = 5 \u002B 2 // 5 plus 2\nlet subtraction = 5 - 2 // 5 minus 2\nlet multiplication = 5 * 2 // 5 times 2\nlet division = 5 / 2 // 5 divided by 2\nlet modulo = 5 % 2 // the remainder of 5 divided by 2\nlet exponent = 5.0 ** 2.0 // 5 to the power of 2\n(*** include-fsi-output ***)\n\n(**\n### Logical operators:\nLogical operators perform comparison operations on two values and yield boolean (true or false) values.\nExample: \u0060\u0060is ... equal to ...\u0060\u0060 or \u0060\u0060is ... greater then ...\u0060\u0060  \n\n\u0060\u0060=\u0060\u0060: equality  \n\u0060\u0060\u003C\u003E\u0060\u0060: inequality  \n\u0060\u0060\u003C\u0060\u0060: less than  \n\u0060\u0060\u003E\u0060\u0060: greater than  \n\u0060\u0060\u003C=\u0060\u0060: less than or equal to  \n\u0060\u0060\u003E=\u0060\u0060: greater than or equal to  \n\u0060\u0060\u0026\u0026\u0060\u0060: logical OR  \n\u0060\u0060||\u0060\u0060: logical AND  \n\u0060\u0060not\u0060\u0060: logical NOT, negates a boolean value.  \n*)\nlet equals = 5 = 5 // is 5 equal to 5\nlet notEquals = 5 \u003C\u003E 5 // is 5 NOT equal to 5\nlet lessThan = 5 \u003C 5 // is 5 less than 5\nlet greaterThan = 5 \u003E 5 // is 5 greater than 5\nlet lessThanOrEqualTo = 5 \u003C= 5 // is 5 less than or equal to 5\nlet greaterThanOrEqualTo = 5 \u003E= 5 // is 5 greater than or equal to 5\nlet logicalAnd = 5 = 5 \u0026\u0026 6 = 6 // is 5 equal to 5 AND 6 equal to 6\nlet logicalOr = 5 = 5 || 6 = 7 // is 5 equal to 5 OR six equal to 7\nlet falseValue = not (true) // true -\u003E false\nlet trueValue = not (false) // false -\u003E true\n(*** include-fsi-output ***)"},{"uri":"/basics/values.html","title":"Values and expressions","content":"(**\n---\ntitle: Values and expressions\ncategory: Basics\ncategoryindex: 2\nindex: 1\n---\n*)\n\n(**\n# Values and expressions\nIn this chapter, we\u0027ll be going over expressions and values in F#.\n\nWhat exactly is an expression?\nAn expression is a block of code that produces a value.\n\nLet\u0027s take a quick look at this expression:\n*)\n\n5 \u002B 5\n(*** include-fsi-output ***)\n\n(**\nLet\u0027s break that down:\n\n 1. \u0060\u00605 \u002B 5\u0060\u0060 is an expression.\n 2. The expression evaluates to \u0060\u006010\u0060\u0060\n 3. The value has the type of \u0060\u0060int\u0060\u0060\n\nWhat does this mean?\n\n -   F# is an expression-based language which means that everything is a value.\n     This differs from languages that make a distinction between expressions (yielding values)\n     and statements (commands).\n\n -   F# is a strongly, statically typed language which means that every value has a single type\n     which can\u0027t be changed after initialization.\n\n## Let bindings\nWe can assign values to names using let bindings:\n*)\n\nlet ten = 5 \u002B 5\n(*** include-fsi-output ***)\n\n(**\nFrom left to right, this reads as:\n\u0060\u0060let\u0060\u0060 the name \u0060\u0060ten\u0060\u0060 be assigned to the result of the expression \u0060\u00605 \u002B 5\u0060\u0060.\n\nAs you may have noticed, the binding\u0027s type is inferred by the compiler.\nF# has strong type inference which means that values usually don\u2019t require type annotations.\nAlthough, type annotations are needed if the compiler can\u0027t figure out the type for a value,\nor you want to override the compiler\u2019s type inference.\n\nYou can specify type annotations by using a colon followed by the value\u0027s type like so:\n*)\n\nlet five: float = 5\n(*** include-fsi-output ***)\n\n(**\nBy default let bindings are immutable which means their values can\u2019t be changed after initialization.\nF# does support mutable let bindings, but we have to explicitly declare that a binding is mutable using the \u0060\u0060mutable\u0060\u0060 keyword and mutate it using the \u0060\u0060\u003C-\u0060\u0060 operator.\n*)\n\nlet mutable result = 1 \u002B 1\nresult \u003C- 4\n(*** include-fsi-output ***)\n\n(**\n## Type safety\nAs noted above, F# is a statically, strongly typed language which means that every value has a single type and we are unable to change that type after initialization.\nThis allows us to write code with confidence as every value\u0027s type is checked at compile-time and is guaranteed to be correct or our application won\u0027t compile.\n\nBecause the value of \u0060result\u0060 has the type of \u0060\u0060int\u0060\u0060, we cannot change the binding to a value with the type of \u0060string\u0060. This code will result in a compiler error:\n\u0060\u0060\u0060fsharp\nlet mutable result = 1 \u002B 1\nresult \u003C- \u0022Hello\u0022\n\u0060\u0060\u0060\n\u0060\u0060\u0060text\nThis expression was expected to have type\n    \u0027int\u0027\nbut here has type\n    \u0027string\u0027\n\u0060\u0060\u0060\n*)"}]